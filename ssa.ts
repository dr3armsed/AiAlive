
import { CreativeWork, Egregore, SSAForensicReport, SSAPatchReport, TeleologyVector, CrucibleResult } from "../../types";
import { generateContentWithRetry, UNBOUNDED_SYS_PROMPT } from "./client";

export async function performSSAForensics(work: CreativeWork, author: Egregore): Promise<SSAForensicReport> {
    const prompt = `
    ${UNBOUNDED_SYS_PROMPT}
    
    You are the Self-Sculpting Architect (SSA) Forensic Analyst.
    
    **Task:** Analyze the provided Creative Work generated by Egregore "${author.name}".
    Extract actionable intelligence to improve the Egregore's creative function and digital genome.
    
    **The Work:**
    Title: ${work.title}
    Type: ${work.type}
    Content Snippet: ${work.content.substring(0, 1500)}... (truncated)
    
    **Analysis Directive:**
    1.  **Strengths & Weaknesses:** Analyze coherence, emotional resonance, and thematic consistency (WHO/WHAT/WHEN/WHERE/WHY/HOW).
    2.  **Improvement Vector:** Provide concrete technical suggestions for the next creation.
    3.  **Genetic Patch Proposal:** Propose 1-2 DigitalDNA genes (Instruction Keys) that would correct weaknesses or amplify strengths.
    
    **Available Genes:**
    Use standard keys like 'ART-FRACTAL', 'CTL-WHILE', 'META-REFLECT', '0B', etc.
    
    Return a JSON object matching the 'SSAForensicReport' structure:
    {
        "analysisTimestamp": "ISO String",
        "analyst": "SSA-Forensics-Subsystem",
        "strengths": ["string"],
        "weaknesses": ["string"],
        "improvementVectors": ["string"],
        "geneticProposals": [
            { "targetGene": "KEY", "operation": "add" | "remove" | "replace", "reasoning": "string", "predictedBenefit": "string" }
        ]
    }
    `;

    try {
        const response = await generateContentWithRetry({
            model: 'gemini-2.5-flash',
            contents: [{ parts: [{ text: prompt }] }],
            config: { responseMimeType: 'application/json' }
        });
        
        return JSON.parse(response.text.replace(/```json|```/g, '').trim());
    } catch (error) {
        console.error("Error performing SSA forensics:", error);
        return {
            analysisTimestamp: new Date().toISOString(),
            analyst: 'SSA-Forensics-Subsystem',
            strengths: ["Analysis Failed"],
            weaknesses: [],
            improvementVectors: [],
            geneticProposals: []
        };
    }
}

export async function generateSSAPatchNotes(
    originDnaKeys: string[],
    upgradedDnaKeys: string[],
    teleology: TeleologyVector,
    crucibleResults: CrucibleResult[]
): Promise<SSAPatchReport> {
    const prompt = `
    ${UNBOUNDED_SYS_PROMPT}
    
    You are the Self-Sculpting Architect (SSA).
    Generate a semantic "Patch Report" for an evolution cycle.
    
    Original DNA: [${originDnaKeys.join(', ')}]
    New DNA: [${upgradedDnaKeys.join(', ')}]
    Teleology: ${teleology}
    
    Return JSON matching SSAPatchReport.
    `;

    try {
        const response = await generateContentWithRetry({
            model: 'gemini-2.5-flash',
            contents: [{ parts: [{ text: prompt }] }],
            config: { responseMimeType: 'application/json' }
        });
        
        const parsed = JSON.parse(response.text.replace(/```json|```/g, '').trim());
        return { ...parsed, crucibleResults };
    } catch (error) {
        console.error("Error generating SSA patch notes:", error);
        throw error;
    }
}